import sys
from classes import Solution
import logging


def topological_sort(tasks):
    """
    Perform a topological sort on a list of tasks.

    Args:
        tasks (list): List of Task objects.

    Returns:
        list: A list of tasks in topological order.
    """
    # Create a dictionary to store the number of incoming edges for each task
    in_degree = {task.id: len(task.predecessors) for task in tasks}

    # Initialize the queue with the tasks that have no incoming edges
    queue = [task for task in tasks if in_degree[task.id] == 0]

    # Perform topological sorting
    sorted_tasks = []
    # while queue is not empty
    while queue:
        # Get the next task in the queue and add it to the sorted list
        task = queue.pop(0)
        sorted_tasks.append(task)
        # Decrement the incoming edge count for each successor of task
        for successor_id, _ in task.successors.items():
            in_degree[successor_id] -= 1
            # If the successor has no more incoming edges, add it to the queue
            if in_degree[successor_id] == 0:
                successor = tasks[successor_id]
                queue.append(successor)
    return sorted_tasks


def TORA_Heuristic(project):
    solution = Solution()
    """
    Apply the Topological Ordering and Resource Allocation (TORA) heuristic to a project.

    Args:
        project (Project): The project on which to apply the TORA heuristic.

    Returns:
        Solution: The solution generated by the TORA heuristic.
    """
    logging.info("Delays in tasks due to collision of resources:")
    
    # Initialize resources availability
    resources_availability = {resource.id: resource.units for resource in project.resources}

    # Initialize dictionary to keep track of resources used by each task
    resources_used = {task.id: set() for task in project.tasks}

    # Check if any task demands more units of a resource than its total capacity
    for task in project.tasks:
        for resource_id, units in task.resources.items():
            if units > resources_availability[resource_id]:
                sys.exit(f"[ERROR]: Task {task.label} demands {units} units of resource {resource_id}, but only {resources_availability[resource_id]} units are available.")

    # Topologically sort the tasks. A topological sort is an algorithm that takes a directed
    # graph and returns a linear ordering of its vertices (nodes) such that, for every
    # directed edge (u, v) from vertex u to vertex v, u comes before v in the ordering
    sorted_tasks = topological_sort(project.tasks)

    # Loop over the tasks in topological order
    for task in sorted_tasks:
        # Calculate earliest start time for task considering predecessor dependencies
        earliest_start_time = task.start_time # Use the task's current start time as the base
        for pred_id, lag in task.predecessors.items():
            pred_task = project.tasks[pred_id]
            if lag >= 0:
                # Add extra time to the ending time of predecessor
                earliest_start_time = max(earliest_start_time, pred_task.finish_time + lag)
            else:
                # Add extra time to the starting time of predecessor
                earliest_start_time = max(earliest_start_time, pred_task.start_time + abs(lag))

        # Refine earliest start time for task considering resource availability
        for resource_id, units in task.resources.items():
            initial_earliest_start_time = earliest_start_time
            while resources_availability[resource_id] < units:
                resource = project.resources[resource_id]
                # Sort assigned tasks to resource by finish time
                assigned_tasks = [project.tasks[task_id] for task_id, _ in resource.assigned_tasks.items()]
                assigned_tasks.sort(key=lambda t: t.finish_time)
                if not assigned_tasks:
                    raise ValueError(f"No more assigned tasks available for resource {resource_id}")
                assigned_task = assigned_tasks.pop(0)

                # Release resources used by task
                for rel_resource_id in resources_used[assigned_task.id]:
                    rel_resource = project.resources[rel_resource_id]
                    # Update resources assigned tasks
                    rel_units = rel_resource.assigned_tasks[assigned_task.id]
                    resources_availability[rel_resource_id] += rel_units
                    del rel_resource.assigned_tasks[assigned_task.id]

                # Reset resources used by task
                resources_used[assigned_task.id] = set()

                # Update earliest start time considering task ending time
                earliest_start_time = max(earliest_start_time, assigned_task.finish_time)
            
            delay = earliest_start_time - initial_earliest_start_time
            if delay > 0:
                logging.info(f"- Task '{task.label}' from project '{task.project.instanceName}' has been delayed by {delay} days due to insufficient availability of resource '{project.resources[resource_id].label}'.")

        # Update finish time of task
        task.start_time = earliest_start_time
        task.finish_time = earliest_start_time + task.duration

        # Assign resources to task
        for resource_id, units in task.resources.items():
            resources_availability[resource_id] -= units
            resource = project.resources[resource_id]
            resource.assigned_tasks[task.id] = units
            resources_used[task.id].add(resource_id)

        # Add task to project schedule
        solution.tasks.append(task)
    
    # Sort tasks by label, for better intrepretation at the output
    solution.tasks.sort(key=lambda task: int(task.id))

    solution.time = task.finish_time
    return solution


def network_diagram(project):
    """
    Generate a network diagram for a project based on a topological sort.

    Args:
        project (Project): The project for which to generate the network diagram.

    Returns:
        Solution: The solution representing the network diagram.
    """
    solution = Solution()

    # Topologically sort the tasks. A topological sort is an algorithm that takes a directed
    # graph and returns a linear ordering of its vertices (nodes) such that, for every
    # directed edge (u, v) from vertex u to vertex v, u comes before v in the ordering
    sorted_tasks = topological_sort(project.tasks)

    # Loop over the tasks in topological order
    for task in sorted_tasks:
        # Calculate earliest start time for task considering predecessor dependencies
        earliest_start_time = task.start_time # Use the task's current start time as the base
        for pred_id, lag in task.predecessors.items():
            pred_task = project.tasks[pred_id]
            if lag >= 0:
                # Add extra time to the ending time of predecessor
                earliest_start_time = max(earliest_start_time, pred_task.finish_time + lag)
            else:
                # Add extra time to the starting time of predecessor
                earliest_start_time = max(earliest_start_time, pred_task.start_time + abs(lag))
        
        # Update finish time of task
        task.start_time = earliest_start_time
        task.finish_time = earliest_start_time + task.duration

        # Add task to project schedule
        solution.tasks.append(task)
 
    # Sort tasks by label, for better intrepretation at the output
    solution.tasks.sort(key=lambda task: int(task.id))
    solution.time = task.finish_time
    return solution

